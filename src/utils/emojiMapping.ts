// A mapping of Weibo emoji codes to standard Unicode emojis
export const emojiMapping: Record<string, string> = {
  // Basic emoticons
  "[å¾®ç¬‘]": "ðŸ˜Š",
  "[å˜»å˜»]": "ðŸ˜",
  "[å“ˆå“ˆ]": "ðŸ˜„",
  "[çˆ±ä½ ]": "â¤ï¸",
  "[æŒ–é¼»]": "ðŸ‘ƒ",
  "[åƒæƒŠ]": "ðŸ˜²",
  "[æ™•]": "ðŸ˜µ",
  "[æ³ª]": "ðŸ˜¢",
  "[é¦‹å˜´]": "ðŸ˜‹",
  "[æŠ“ç‹‚]": "ðŸ˜«",
  "[å“¼]": "ðŸ˜¤",
  "[å¯çˆ±]": "ðŸ˜Š",
  "[æ€’]": "ðŸ˜ ",
  "[æ±—]": "ðŸ˜“",
  "[å®³ç¾ž]": "ðŸ˜³",
  "[ç¡]": "ðŸ˜´",
  "[é’±]": "ðŸ’°",
  "[å·ç¬‘]": "ðŸ˜",
  "[ç¬‘cry]": "ðŸ˜‚",
  "[doge]": "ðŸ¶",
  "[å–µå–µ]": "ðŸ±",
  "[äºŒå“ˆ]": "ðŸ¤ª",
  "[å…æ‚²]": "ðŸ¤£",
  "[é…·]": "ðŸ˜Ž",
  "[è¡°]": "ðŸ˜©",
  "[æ€è€ƒ]": "ðŸ¤”",
  "[ç–‘é—®]": "â“",
  "[æ‹œæ‹œ]": "ðŸ‘‹",
  "[é¼“æŽŒ]": "ðŸ‘",
  "[æ¡æ‰‹]": "ðŸ¤",
  "[èµž]": "ðŸ‘",
  "[å¿ƒ]": "â¤ï¸",
  "[ä¼¤å¿ƒ]": "ðŸ’”",
  "[é²œèŠ±]": "ðŸŒ¹",
  "[å¤ªé˜³]": "â˜€ï¸",
  "[æœˆäº®]": "ðŸŒ™",
  "[å¨æ­¦]": "ðŸ’ª",
  "[ç»™åŠ›]": "ðŸ‘",
  "[å¯æ€œ]": "ðŸ¥º",
  "[å³å“¼å“¼]": "ðŸ˜¤",
  "[å·¦å“¼å“¼]": "ðŸ˜¤",
  "[å˜˜]": "ðŸ¤«",
  "[å§”å±ˆ]": "ðŸ˜¢",
  
  // Additional mappings
  "[æ†§æ†¬]": "ðŸ¤©",
  "[å]": "ðŸ¤®",
  "[å“ˆæ¬ ]": "ðŸ¥±",
  "[ç™½çœ¼]": "ðŸ™„",
  "[å‘µå‘µ]": "ðŸ™‚",
  "[é»‘çº¿]": "ðŸ˜…",
  "[åç¬‘]": "ðŸ˜¬",
  "[èŠ±å¿ƒ]": "ðŸ˜",
  "[å¤±æœ›]": "ðŸ˜”",
  "[æ‚²ä¼¤]": "ðŸ˜¥",
  "[é—­å˜´]": "ðŸ¤",
  "[åƒç“œ]": "ðŸ‰",
  "[è´¹è§£]": "ðŸ¤¨",
  "[æ„Ÿå†’]": "ðŸ˜·",
  "[é„™è§†]": "ðŸ˜’",
  "[è·ªäº†]": "ðŸ§Ž",
  "[ç”Ÿç—…]": "ðŸ¤’",
  "[æ‰“è„¸]": "ðŸ¤•",
  "[æ‘Šæ‰‹]": "ðŸ¤·",
  "[çŒªå¤´]": "ðŸ·",
  "[ç¬‘å“­]": "ðŸ˜‚",
  "[é˜´é™©]": "ðŸ˜",
  "[æ€’éª‚]": "ðŸ¤¬",
  "[å‚»çœ¼]": "ðŸ˜³",
  "[äº’ç²‰]": "ðŸ¤",
  "[å‘æ€’]": "ðŸ˜¡",
  "[è·³èˆž]": "ðŸ’ƒ",
  "[çŒ®èŠ±]": "ðŸŒ¹",
  "[è€¶]": "âœŒï¸",
  "[æœ€å³]": "ðŸ‘‰",
  "[é£žå»]": "ðŸ˜˜",
  "[æ±‚é¥¶]": "ðŸ™",
  "[å¥¥ç‰¹æ›¼]": "ðŸ¦¸",
  "[å•¤é…’]": "ðŸ»",
  "[èœ¡çƒ›]": "ðŸ•¯ï¸",
  "[ç¤¼ç‰©]": "ðŸŽ",
  
  // Special symbols
  "[éŸ³ä¹]": "ðŸŽµ",
  "[ç…§ç›¸æœº]": "ðŸ“·",
  "[è¯ç­’]": "ðŸŽ¤",
  "[å˜¿å“ˆ]": "ðŸ¤ ",
  "[æ¥]": "ðŸ‘ˆ",
  "[çˆ±å¿ƒ]": "â¤ï¸",
  "[å¿ƒç¢Ž]": "ðŸ’”",
  "[è›‹ç³•]": "ðŸŽ‚",
  "[é£žæœº]": "âœˆï¸",
  "[å†è§]": "ðŸ‘‹",
  "[ç¥ˆç¥·]": "ðŸ™",
  "[å›°]": "ðŸ˜´",
  
  // Weather
  "[å¾®é£Ž]": "ðŸƒ",
  "[ä¸‹é›¨]": "ðŸŒ§ï¸",
  "[ä¸‹é›ª]": "â„ï¸",
  
  // Animals
  "[ç†ŠçŒ«]": "ðŸ¼",
  "[å…”å­]": "ðŸ°",
  "[çŒª]": "ðŸ·",
  
  // Food
  "[å’–å•¡]": "â˜•",
  "[å¯ä¹]": "ðŸ¥¤",
  "[å†°æ¿€å‡Œ]": "ðŸ¦",
};

// Function to replace Weibo emojis with standard emojis
export const convertWeiboEmojis = (text: string): string => {
  let convertedText = text;
  
  // Replace all occurrences of Weibo emojis
  Object.entries(emojiMapping).forEach(([weiboEmoji, standardEmoji]) => {
    const regex = new RegExp(weiboEmoji.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g');
    convertedText = convertedText.replace(regex, standardEmoji);
  });
  
  return convertedText;
};

// Function to convert specific recky hashtags
export const convertReckyHashtags = (text: string): string => {
  // Match the exact pattern "#recky blah#" only
  return text.replace(/#recky blah#/g, '#reckyçš„æ–‡å­—');
};

// Function to convert Weibo hashtags from #xxxx# to #xxxx format
export const convertWeiboHashtags = (text: string): string => {
  // Match patterns like #xxxx# to convert to #xxxx
  return text.replace(/#([^#\s]+)#/g, '#$1');
};

// Function to extract all hashtags from text
export const extractHashtags = (text: string): string[] => {
  // Extract hashtags using a simple regex
  const hashtagRegex = /#[^#\s]+/g;
  const matches = text.match(hashtagRegex) || [];
  return Array.from(new Set(matches));
};

// Paragraph marker options
export type MarkerStyle = 'âž¤' | 'ðŸ”¹' | 'ðŸŒ¸' | 'âœ¨' | 'ðŸ’ ' | 'ðŸ€';

// Function to add paragraph markers
export const addParagraphMarkers = (text: string, markerStyle: MarkerStyle = 'âž¤'): string => {
  // Split text by newlines and add selected paragraph marker to each non-empty paragraph
  return text
    .split('\n')
    .map(paragraph => paragraph.trim() ? `${markerStyle} ${paragraph}` : paragraph)
    .join('\n');
};

// Function to split text into chunks for platforms with character limits
export const splitTextIntoChunks = (text: string, maxChunkSize: number = 900): string[] => {
  // Extract all hashtags from the text - these are already converted to #xxxx format
  const hashtags = extractHashtags(text);
  const hashtagString = hashtags.length > 0 ? '\n\n' + hashtags.join(' ') : '';
  
  if (text.length <= maxChunkSize - hashtagString.length) {
    return [text + hashtagString];
  }

  const chunks: string[] = [];
  let remainingText = text;

  while (remainingText.length > 0) {
    const availableSize = maxChunkSize - (hashtags.length > 0 ? hashtags.join(' ').length + 2 : 0);
    
    if (remainingText.length <= availableSize) {
      // For the last chunk, don't add hashtags at all
      chunks.push(remainingText);
      break;
    }

    // Find a good split point
    let splitIndex = findSplitIndex(remainingText, availableSize);
    
    // Add the chunk with hashtags appended
    chunks.push(remainingText.substring(0, splitIndex).trim() + hashtagString);
    
    // Update remaining text
    remainingText = remainingText.substring(splitIndex).trim();
  }

  return chunks;
};

// Helper function to find a good split point
const findSplitIndex = (text: string, maxLength: number): number => {
  // First try to split at a paragraph (double newline)
  const paragraphSplit = text.lastIndexOf('\n\n', maxLength);
  if (paragraphSplit > 0 && paragraphSplit >= maxLength / 2) {
    return paragraphSplit + 2; // Include the double newline in the first chunk
  }
  
  // Then try to split at a single newline
  const newlineSplit = text.lastIndexOf('\n', maxLength);
  if (newlineSplit > 0 && newlineSplit >= maxLength / 2) {
    return newlineSplit + 1; // Include the newline in the first chunk
  }
  
  // Then try to split at a sentence end (.!?)
  const sentenceMatch = text.substring(0, maxLength).match(/[.!?][^.!?]*$/);
  if (sentenceMatch && sentenceMatch.index && sentenceMatch.index >= maxLength / 2) {
    return sentenceMatch.index + 1;
  }
  
  // If all else fails, split at a space
  const spaceSplit = text.lastIndexOf(' ', maxLength);
  if (spaceSplit > 0 && spaceSplit >= maxLength / 2) {
    return spaceSplit + 1; // Include the space in the first chunk
  }
  
  // Last resort: just split at the max length
  return maxLength;
}; 